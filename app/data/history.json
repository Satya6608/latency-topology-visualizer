import { NextResponse } from "next/server";
import fs from "fs";
import path from "path";
import exchanges from "../../data/exchanges.json";
import countryData from "../../data/countryCoordinates.json";

interface CloudflareLatency {
  p25: number;
  p50: number;
  p75: number;
}

const HISTORY_DIR = path.join(process.cwd(), "app", "data", "history");

function ensureDir(dir: string) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function haversine(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371;
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLon = ((lon2 - lon1) * Math.PI) / 180;
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos((lat1 * Math.PI) / 180) *
      Math.cos((lat2 * Math.PI) / 180) *
      Math.sin(dLon / 2) ** 2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

async function fetchCloudflareLatency(location: string): Promise<CloudflareLatency> {
  const token = process.env.CLOUDFLARE_API_TOKEN;
  if (!token)
    return { p25: Math.random() * 60, p50: Math.random() * 100, p75: Math.random() * 150 };

  const url = `https://api.cloudflare.com/client/v4/radar/quality/iqi/timeseries_groups?metric=LATENCY&aggInterval=1h&location=${location}&dateRange=1d&format=JSON`;
  try {
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${token}` },
      cache: "no-store",
    });
    const json = await res.json();
    const s = json.result?.serie_0 || {};
    return {
      p25: parseFloat(s.p25?.at(-1) || "0"),
      p50: parseFloat(s.p50?.at(-1) || "0"),
      p75: parseFloat(s.p75?.at(-1) || "0"),
    };
  } catch {
    return { p25: 0, p50: 0, p75: 0 };
  }
}

export async function GET() {
  const encoder = new TextEncoder();
  ensureDir(HISTORY_DIR);

  const stream = new ReadableStream({
    async start(controller) {
      const probes = ["US", "GB", "IN", "SG", "DE"];
      const now = new Date().toISOString();
      const dateFile = path.join(HISTORY_DIR, `${now.slice(0, 10)}.json`);

      const promises = probes.map(async (code) => {
        const coords = (countryData as any)[code];
        const latency = await fetchCloudflareLatency(code);

        const nearest = (exchanges as any[])
          .map((ex) => ({
            ...ex,
            distanceKm: haversine(coords.lat, coords.lng, ex.lat, ex.lng),
          }))
          .sort((a, b) => a.distanceKm - b.distanceKm)
          .slice(0, 3);

        const snapshot = {
          timestamp: now,
          location: code,
          country: coords.country,
          latency,
          exchanges: nearest.map((ex) => ({
            id: ex.id,
            name: ex.name,
            provider: ex.provider,
            distanceKm: parseFloat(ex.distanceKm.toFixed(2)),
          })),
        };

        fs.appendFileSync(dateFile, JSON.stringify(snapshot) + "\n");

        controller.enqueue(encoder.encode(`data: ${JSON.stringify(snapshot)}\n\n`));
      });

      for await (const _ of promises);
      controller.enqueue(encoder.encode("event: end\ndata: done\n\n"));
      controller.close();
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive",
    },
  });
}
